# -*- coding: utf-8 -*-
"""Comunicación_FBF.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/14D7upN3xY9QwMJVmZUv6aY9u4ISoKHKz

# ULTIMA EJECUCIÓN EL 10/04
### Los campos "main_warehouse_email_prueba" ,	"return_warehouse_email_prueba" , sirven solo para las pruebas, al igual que el excel.

# HASTA AHORA EL MAXIMO DE CORREOS FUE DE 418, SIN CAERSE con 1945 registros -> 4 min 33 s

#ULTIMA EJECUCION DEL 26/03 DIO UN DATAFRAME DE 0 CAMBIOS DETECTADOS
"""

# Importaciones necesarias
import pandas as pd
from email.mime.application import MIMEApplication
import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from email.mime.image import MIMEImage
import base64


import math  # Necesario para verificar NaN
import os

#Conexion con GCP
from google.colab import auth
from google.cloud import bigquery

#Cargar los datos desde GCP

# Autenticación
auth.authenticate_user()

# Proyecto y cliente de BigQuery
project_id = 'bi-fcom-drmb-local-pe-sbx'
client = bigquery.Client(project=project_id)

# Consulta
query = f"""
    select * from  bi-fcom-drmb-local-pe-sbx.VL_PE.cambio_tallas_sku
"""

# Cargar el DataFrame
df = client.query(query).to_dataframe()

# Ver las primeras filas del DataFrame
df.head()

# Nnúmero total de regisros Actualizados en el DataFrame
num_rows = df.shape[0]
print("Número total de filas en el DataFrame:", num_rows)

#Ver la cantidad de correos a enviar, por SellerID
cant_sellers = df['sellerID'].nunique()
print("La cantidad de Correos (Sellers) a enviar son:", cant_sellers)

#Guardar en un Excel para hacer las pruebas

# df.to_excel('df.xlsx', index=False)

# Importación del archivo Excel df, par alas pruebas

# df_pruebas = pd.read_excel('/content/df.xlsx')

#Visualizar el df de pruebas , con la cantidad descrita previamente
# Convert the data to a Pandas DataFrame
df.head(1945)

#Seleccionar los campos necesarios "sku" , "sku_seller", "last_size_update" , "new_item_size" , "previous_item_size"
#Los encabezados tomarian nombre de "SKU" , "Sku_Seller", "Fecha_Modificación" , "Nueva_Talla_SKU" , "Anterior_Talla_SKU"

# df_campos_utiles = df.loc[:, ["sellerID","seller", "sku", "sku_seller", "last_size_update", "new_item_size", "previous_item_size","main_warehouse_email_prueba","return_warehouse_email_prueba"]]
df_campos_utiles = df.loc[:, ["sellerID","seller", "sku", "sku_seller", "last_size_update", "new_item_size", "previous_item_size","main_warehouse_email","return_warehouse_email"]]

# Visualizar el nuevo DataFrame
df_campos_utiles.head(1945)

#Libreria para trabajar con Excel
from openpyxl.styles import Font, PatternFill
from openpyxl.utils.dataframe import dataframe_to_rows
import base64
import openpyxl
import socket
import smtplib

# Configuración
email_usuario = 'correo@falabella.com'
contrasena = 'contraseña'
asunto_base = 'Cambio de tamaño de SKU'

# Establecer la conexión con el servidor SMTP de Outlook con un tiempo de espera de 30 segundos
server = smtplib.SMTP('smtp.office365.com', 587, timeout=30)
server.starttls()

# Iniciar sesión en el servidor SMTP
server.login(email_usuario, contrasena)

# Iterar sobre las tiendas únicas en el DataFrame
for sellerID in df_campos_utiles['sellerID'].unique():
    # Filtrar el DataFrame para la tienda actual
    df_seller = df_campos_utiles[df_campos_utiles['sellerID'] == sellerID].copy()

    # Obtener el nombre del vendedor ('seller') de la primera fila del DataFrame filtrado
    seller_name = df_seller['seller'].iloc[0]

    # Obtener la dirección de correo electrónico de la tienda actual
    # correo_seller_1 = df_seller['main_warehouse_email_prueba'].iloc[0]
    # correo_seller_2 = df_seller['return_warehouse_email_prueba'].iloc[0]
    correo_seller_1 = df_seller['main_warehouse_email'].iloc[0]
    correo_seller_2 = df_seller['return_warehouse_email'].iloc[0]


    # Verificar si la dirección de correo electrónico es NaN
    if isinstance(correo_seller_1, float) and math.isnan(correo_seller_1):
        print(f"La dirección de correo electrónico para la tienda {sellerID} es nula (NaN). No se enviará el correo.")
        continue

    # Verificar si la dirección de correo electrónico es NaN
    if isinstance(correo_seller_2, float) and math.isnan(correo_seller_2):
        print(f"La dirección de correo electrónico para la tienda {sellerID} es nula (NaN). No se enviará el correo.")
        continue

    # Configurar el mensaje
    msg = MIMEMultipart()
    msg['From'] = 'fcomlogisticasx@falabella.com'
    msg['To'] = ', '.join([correo_seller_1, correo_seller_2]) #correo_seller_2
    msg['Subject'] = f"{seller_name}: {asunto_base} "

    # Seleccionar columnas específicas para mostrar en el cuerpo del correo
    columnas_seleccionadas = ["sku", "sku_seller", "last_size_update", "new_item_size", "previous_item_size"]
    df_seller_seleccionada = df_seller[columnas_seleccionadas]

    # Renombrar las columnas en el DataFrame seleccionado
    df_seller_seleccionada = df_seller_seleccionada.rename(columns={
        'last_size_update': 'Fecha modificacion',
        'new_item_size': 'Nueva talla sku',
        'previous_item_size': 'Anterior talla sku',
        'sku': 'SKU',
        'sku_seller': 'Sku_Seller'
    })

    # Convertir la columna 'last_size_update' a tipo datetime si no lo está
    df_seller_seleccionada['Fecha modificacion'] = pd.to_datetime(df_seller_seleccionada['Fecha modificacion'])

    # Formatear la columna de fechas para que solo muestre la fecha sin la hora
    df_seller_seleccionada['Fecha modificacion'] = df_seller_seleccionada['Fecha modificacion'].dt.date

    # Guardar el DataFrame de la tienda actual en un archivo Excel
    nombre_archivo_excel = f"Informe_Cambio_Tallas{sellerID}.xlsx"
    df_seller_seleccionada.to_excel(nombre_archivo_excel, index=False)

    # Dar formato al encabezado del Excel
    wb = openpyxl.load_workbook(nombre_archivo_excel)
    ws = wb.active
    encabezados = ["SKU", "Sku_Seller", "Fecha_Modificación", "Nueva_Talla_SKU", "Anterior_Talla_SKU"]
    for col, encabezado in enumerate(encabezados, start=1):
        celda = ws.cell(row=1, column=col, value=encabezado)
        celda.font = Font(bold=True, color="000000")  # Negrita y color de fuente negro
        celda.fill = PatternFill(start_color="FFA500", end_color="FFA500", fill_type="solid")  # Fondo naranja

    # Ajustar automáticamente el ancho de las columnas
    for column_cells in ws.columns:
        length = max(len(str(cell.value)) for cell in column_cells)
        ws.column_dimensions[column_cells[0].column_letter].width = length + 2

    # Guardar el libro de trabajo con los cambios realizados
    wb.save(nombre_archivo_excel)
    # Cerrar el libro de trabajo después de guardar los cambios
    wb.close()

    # Adjuntar el archivo Excel al correo electrónico
    with open(nombre_archivo_excel, "rb") as attachment:
        part = MIMEApplication(attachment.read(), Name=os.path.basename(nombre_archivo_excel))
        part['Content-Disposition'] = f'attachment; filename="{os.path.basename(nombre_archivo_excel)}"'
        msg.attach(part)

    # Codificar la imagen en base64
    ruta_imagen = "/content/Cambio_Talla.png"
    with open(ruta_imagen, "rb") as file:
        imagen_codificada = base64.b64encode(file.read()).decode('utf-8')

    # Crear el cuerpo del correo en formato HTML con la imagen incrustada
    mensaje_html = f"""
    <html>
    <body>
        <img src="data:image/png;base64,{imagen_codificada}" alt="Cambio Talla">

    </body>
    </html>
    """

    # Adjuntar el cuerpo del correo en formato HTML
    msg.attach(MIMEText(mensaje_html, 'html'))

    # Enviar el correo electrónico
    server.sendmail(email_usuario, [correo_seller_1, correo_seller_2], msg.as_string()) #correo_seller_2

    # Eliminar el archivo Excel después de enviar el correo
    os.remove(nombre_archivo_excel)

# Cerrar la conexión con el servidor SMTP
server.quit()